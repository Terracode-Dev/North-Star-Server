// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: empSchedual.sql

package database

import (
	"context"
	"database/sql"
	"time"
)

const countEmployeesWithFilters = `-- name: CountEmployeesWithFilters :one
SELECT COUNT(*) as total
FROM HR_Employee e
LEFT JOIN HR_EMP_User u ON e.id = u.employee_id
WHERE 
    (? = '' OR e.first_name LIKE CONCAT('%', ?, '%'))
    AND (? = '' OR e.last_name LIKE CONCAT('%', ?, '%'))
    AND (? = '' OR u.email LIKE CONCAT('%', ?, '%'))
`

type CountEmployeesWithFiltersParams struct {
	Column1  interface{} `json:"column_1"`
	CONCAT   interface{} `json:"CONCAT"`
	Column3  interface{} `json:"column_3"`
	CONCAT_2 interface{} `json:"CONCAT_2"`
	Column5  interface{} `json:"column_5"`
	CONCAT_3 interface{} `json:"CONCAT_3"`
}

// Count total employees for pagination (with same filters)
func (q *Queries) CountEmployeesWithFilters(ctx context.Context, arg CountEmployeesWithFiltersParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countEmployeesWithFilters,
		arg.Column1,
		arg.CONCAT,
		arg.Column3,
		arg.CONCAT_2,
		arg.Column5,
		arg.CONCAT_3,
	)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const createAdditionalSchedule = `-- name: CreateAdditionalSchedule :exec
INSERT INTO HR_EMP_SCHEDUAL_additional (emp_id, date, from_time, to_time)
VALUES (?, ?, ?, ?)
`

type CreateAdditionalScheduleParams struct {
	EmpID    int64        `json:"emp_id"`
	Date     time.Time    `json:"date"`
	FromTime sql.NullTime `json:"from_time"`
	ToTime   sql.NullTime `json:"to_time"`
}

func (q *Queries) CreateAdditionalSchedule(ctx context.Context, arg CreateAdditionalScheduleParams) error {
	_, err := q.db.ExecContext(ctx, createAdditionalSchedule,
		arg.EmpID,
		arg.Date,
		arg.FromTime,
		arg.ToTime,
	)
	return err
}

const createEmployeeSchedule = `-- name: CreateEmployeeSchedule :exec
INSERT INTO HR_EMP_SCHEDUAL (
    emp_id, monday, monday_from, monday_to,
    tuesday, tuesday_from, tuesday_to,
    wednesday, wednesday_from, wednesday_to,
    thursday, thursday_from, thursday_to,
    friday, friday_from, friday_to,
    saturday, saturday_from, saturday_to,
    sunday, sunday_from, sunday_to
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateEmployeeScheduleParams struct {
	EmpID         int64        `json:"emp_id"`
	Monday        sql.NullBool `json:"monday"`
	MondayFrom    sql.NullTime `json:"monday_from"`
	MondayTo      sql.NullTime `json:"monday_to"`
	Tuesday       sql.NullBool `json:"tuesday"`
	TuesdayFrom   sql.NullTime `json:"tuesday_from"`
	TuesdayTo     sql.NullTime `json:"tuesday_to"`
	Wednesday     sql.NullBool `json:"wednesday"`
	WednesdayFrom sql.NullTime `json:"wednesday_from"`
	WednesdayTo   sql.NullTime `json:"wednesday_to"`
	Thursday      sql.NullBool `json:"thursday"`
	ThursdayFrom  sql.NullTime `json:"thursday_from"`
	ThursdayTo    sql.NullTime `json:"thursday_to"`
	Friday        sql.NullBool `json:"friday"`
	FridayFrom    sql.NullTime `json:"friday_from"`
	FridayTo      sql.NullTime `json:"friday_to"`
	Saturday      sql.NullBool `json:"saturday"`
	SaturdayFrom  sql.NullTime `json:"saturday_from"`
	SaturdayTo    sql.NullTime `json:"saturday_to"`
	Sunday        sql.NullBool `json:"sunday"`
	SundayFrom    sql.NullTime `json:"sunday_from"`
	SundayTo      sql.NullTime `json:"sunday_to"`
}

func (q *Queries) CreateEmployeeSchedule(ctx context.Context, arg CreateEmployeeScheduleParams) error {
	_, err := q.db.ExecContext(ctx, createEmployeeSchedule,
		arg.EmpID,
		arg.Monday,
		arg.MondayFrom,
		arg.MondayTo,
		arg.Tuesday,
		arg.TuesdayFrom,
		arg.TuesdayTo,
		arg.Wednesday,
		arg.WednesdayFrom,
		arg.WednesdayTo,
		arg.Thursday,
		arg.ThursdayFrom,
		arg.ThursdayTo,
		arg.Friday,
		arg.FridayFrom,
		arg.FridayTo,
		arg.Saturday,
		arg.SaturdayFrom,
		arg.SaturdayTo,
		arg.Sunday,
		arg.SundayFrom,
		arg.SundayTo,
	)
	return err
}

const deleteAdditionalSchedule = `-- name: DeleteAdditionalSchedule :exec
DELETE FROM HR_EMP_SCHEDUAL_additional WHERE emp_id = ? AND date = ?
`

type DeleteAdditionalScheduleParams struct {
	EmpID int64     `json:"emp_id"`
	Date  time.Time `json:"date"`
}

func (q *Queries) DeleteAdditionalSchedule(ctx context.Context, arg DeleteAdditionalScheduleParams) error {
	_, err := q.db.ExecContext(ctx, deleteAdditionalSchedule, arg.EmpID, arg.Date)
	return err
}

const deleteAllAdditionalSchedules = `-- name: DeleteAllAdditionalSchedules :exec
DELETE FROM HR_EMP_SCHEDUAL_additional WHERE emp_id = ?
`

func (q *Queries) DeleteAllAdditionalSchedules(ctx context.Context, empID int64) error {
	_, err := q.db.ExecContext(ctx, deleteAllAdditionalSchedules, empID)
	return err
}

const deleteEmployeeSchedule = `-- name: DeleteEmployeeSchedule :exec
DELETE FROM HR_EMP_SCHEDUAL WHERE emp_id = ?
`

func (q *Queries) DeleteEmployeeSchedule(ctx context.Context, empID int64) error {
	_, err := q.db.ExecContext(ctx, deleteEmployeeSchedule, empID)
	return err
}

const getAllAttendance = `-- name: GetAllAttendance :many
SELECT
  DATE(create_date) as date,
  emp_id,
  TIME_FORMAT(MIN(CASE WHEN attendance_type = 'in' THEN TIME(create_date) END), '%H:%i:%s') as in_time,
  TIME_FORMAT(MAX(CASE WHEN attendance_type = 'out' THEN TIME(create_date) END), '%H:%i:%s') as out_time,
  CASE 
    WHEN MIN(CASE WHEN attendance_type = 'in' THEN TIME(create_date) END) IS NOT NULL 
         AND MAX(CASE WHEN attendance_type = 'out' THEN TIME(create_date) END) IS NOT NULL 
    THEN TIME_FORMAT(TIMEDIFF(
      MAX(CASE WHEN attendance_type = 'out' THEN TIME(create_date) END),
      MIN(CASE WHEN attendance_type = 'in' THEN TIME(create_date) END)
    ), '%H:%i:%s')
    ELSE NULL 
  END as total_time
FROM HR_EMP_ATTENDANCE
WHERE emp_id = ?
  AND (? IS NULL OR DATE(create_date) = ?)
GROUP BY DATE(create_date), emp_id
ORDER BY DATE(create_date) DESC
LIMIT ? OFFSET ?
`

type GetAllAttendanceParams struct {
	EmpID      int64       `json:"emp_id"`
	Column2    interface{} `json:"column_2"`
	CreateDate time.Time   `json:"create_date"`
	Limit      int32       `json:"limit"`
	Offset     int32       `json:"offset"`
}

type GetAllAttendanceRow struct {
	Date      time.Time `json:"date"`
	EmpID     int64     `json:"emp_id"`
	InTime    string    `json:"in_time"`
	OutTime   string    `json:"out_time"`
	TotalTime string    `json:"total_time"`
}

func (q *Queries) GetAllAttendance(ctx context.Context, arg GetAllAttendanceParams) ([]GetAllAttendanceRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllAttendance,
		arg.EmpID,
		arg.Column2,
		arg.CreateDate,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllAttendanceRow
	for rows.Next() {
		var i GetAllAttendanceRow
		if err := rows.Scan(
			&i.Date,
			&i.EmpID,
			&i.InTime,
			&i.OutTime,
			&i.TotalTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllAttendanceForAll = `-- name: GetAllAttendanceForAll :many
SELECT
  DATE(create_date) as date,
  emp_id,
  CONCAT(e.first_name, ' ', e.last_name) as name,
  TIME_FORMAT(MIN(CASE WHEN attendance_type = 'in' THEN TIME(create_date) END), '%H:%i:%s') as in_time,
  TIME_FORMAT(MAX(CASE WHEN attendance_type = 'out' THEN TIME(create_date) END), '%H:%i:%s') as out_time,
  CASE 
    WHEN MIN(CASE WHEN attendance_type = 'in' THEN TIME(create_date) END) IS NOT NULL 
         AND MAX(CASE WHEN attendance_type = 'out' THEN TIME(create_date) END) IS NOT NULL 
    THEN TIME_FORMAT(TIMEDIFF(
      MAX(CASE WHEN attendance_type = 'out' THEN TIME(create_date) END),
      MIN(CASE WHEN attendance_type = 'in' THEN TIME(create_date) END)
    ), '%H:%i:%s')
    ELSE NULL 
  END as total_time
FROM HR_EMP_ATTENDANCE
LEFT JOIN HR_Employee e ON emp_id = e.id
WHERE (? IS NULL OR DATE(create_date) = ?)
GROUP BY DATE(create_date), emp_id
ORDER BY DATE(create_date) DESC
LIMIT ? OFFSET ?
`

type GetAllAttendanceForAllParams struct {
	Column1    interface{} `json:"column_1"`
	CreateDate time.Time   `json:"create_date"`
	Limit      int32       `json:"limit"`
	Offset     int32       `json:"offset"`
}

type GetAllAttendanceForAllRow struct {
	Date      time.Time `json:"date"`
	EmpID     int64     `json:"emp_id"`
	Name      string    `json:"name"`
	InTime    string    `json:"in_time"`
	OutTime   string    `json:"out_time"`
	TotalTime string    `json:"total_time"`
}

func (q *Queries) GetAllAttendanceForAll(ctx context.Context, arg GetAllAttendanceForAllParams) ([]GetAllAttendanceForAllRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllAttendanceForAll,
		arg.Column1,
		arg.CreateDate,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllAttendanceForAllRow
	for rows.Next() {
		var i GetAllAttendanceForAllRow
		if err := rows.Scan(
			&i.Date,
			&i.EmpID,
			&i.Name,
			&i.InTime,
			&i.OutTime,
			&i.TotalTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEmpAdditionalSheduleByID = `-- name: GetEmpAdditionalSheduleByID :many
SELECT
    id,
    emp_id,
    date, 
    COALESCE(TIME_FORMAT(from_time, '%H:%i:%s'), '') as from_time, 
    COALESCE(TIME_FORMAT(to_time, '%H:%i:%s'), '') as to_time, 
    created_at, 
    updated_at
FROM HR_EMP_SCHEDUAL_additional 
WHERE emp_id = ?
ORDER BY date DESC
`

type GetEmpAdditionalSheduleByIDRow struct {
	ID        int64        `json:"id"`
	EmpID     int64        `json:"emp_id"`
	Date      time.Time    `json:"date"`
	FromTime  interface{}  `json:"from_time"`
	ToTime    interface{}  `json:"to_time"`
	CreatedAt sql.NullTime `json:"created_at"`
	UpdatedAt sql.NullTime `json:"updated_at"`
}

func (q *Queries) GetEmpAdditionalSheduleByID(ctx context.Context, empID int64) ([]GetEmpAdditionalSheduleByIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getEmpAdditionalSheduleByID, empID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEmpAdditionalSheduleByIDRow
	for rows.Next() {
		var i GetEmpAdditionalSheduleByIDRow
		if err := rows.Scan(
			&i.ID,
			&i.EmpID,
			&i.Date,
			&i.FromTime,
			&i.ToTime,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEmpShedulleByID = `-- name: GetEmpShedulleByID :one
SELECT 
    id,
    emp_id,
    monday,
    COALESCE(TIME_FORMAT(monday_from, '%H:%i:%s'), '') as monday_from,
    COALESCE(TIME_FORMAT(monday_to, '%H:%i:%s'), '') as monday_to,
    tuesday,
    COALESCE(TIME_FORMAT(tuesday_from, '%H:%i:%s'), '') as tuesday_from,
    COALESCE(TIME_FORMAT(tuesday_to, '%H:%i:%s'), '') as tuesday_to,
    wednesday,
    COALESCE(TIME_FORMAT(wednesday_from, '%H:%i:%s'), '') as wednesday_from,
    COALESCE(TIME_FORMAT(wednesday_to, '%H:%i:%s'), '') as wednesday_to,
    thursday,
    COALESCE(TIME_FORMAT(thursday_from, '%H:%i:%s'), '') as thursday_from,
    COALESCE(TIME_FORMAT(thursday_to, '%H:%i:%s'), '') as thursday_to,
    friday,
    COALESCE(TIME_FORMAT(friday_from, '%H:%i:%s'), '') as friday_from,
    COALESCE(TIME_FORMAT(friday_to, '%H:%i:%s'), '') as friday_to,
    saturday,
    COALESCE(TIME_FORMAT(saturday_from, '%H:%i:%s'), '') as saturday_from,
    COALESCE(TIME_FORMAT(saturday_to, '%H:%i:%s'), '') as saturday_to,
    sunday,
    COALESCE(TIME_FORMAT(sunday_from, '%H:%i:%s'), '') as sunday_from,
    COALESCE(TIME_FORMAT(sunday_to, '%H:%i:%s'), '') as sunday_to,
    created_at,
    updated_at
FROM HR_EMP_SCHEDUAL
WHERE emp_id = ?
`

type GetEmpShedulleByIDRow struct {
	ID            int64        `json:"id"`
	EmpID         int64        `json:"emp_id"`
	Monday        sql.NullBool `json:"monday"`
	MondayFrom    interface{}  `json:"monday_from"`
	MondayTo      interface{}  `json:"monday_to"`
	Tuesday       sql.NullBool `json:"tuesday"`
	TuesdayFrom   interface{}  `json:"tuesday_from"`
	TuesdayTo     interface{}  `json:"tuesday_to"`
	Wednesday     sql.NullBool `json:"wednesday"`
	WednesdayFrom interface{}  `json:"wednesday_from"`
	WednesdayTo   interface{}  `json:"wednesday_to"`
	Thursday      sql.NullBool `json:"thursday"`
	ThursdayFrom  interface{}  `json:"thursday_from"`
	ThursdayTo    interface{}  `json:"thursday_to"`
	Friday        sql.NullBool `json:"friday"`
	FridayFrom    interface{}  `json:"friday_from"`
	FridayTo      interface{}  `json:"friday_to"`
	Saturday      sql.NullBool `json:"saturday"`
	SaturdayFrom  interface{}  `json:"saturday_from"`
	SaturdayTo    interface{}  `json:"saturday_to"`
	Sunday        sql.NullBool `json:"sunday"`
	SundayFrom    interface{}  `json:"sunday_from"`
	SundayTo      interface{}  `json:"sunday_to"`
	CreatedAt     sql.NullTime `json:"created_at"`
	UpdatedAt     sql.NullTime `json:"updated_at"`
}

func (q *Queries) GetEmpShedulleByID(ctx context.Context, empID int64) (GetEmpShedulleByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getEmpShedulleByID, empID)
	var i GetEmpShedulleByIDRow
	err := row.Scan(
		&i.ID,
		&i.EmpID,
		&i.Monday,
		&i.MondayFrom,
		&i.MondayTo,
		&i.Tuesday,
		&i.TuesdayFrom,
		&i.TuesdayTo,
		&i.Wednesday,
		&i.WednesdayFrom,
		&i.WednesdayTo,
		&i.Thursday,
		&i.ThursdayFrom,
		&i.ThursdayTo,
		&i.Friday,
		&i.FridayFrom,
		&i.FridayTo,
		&i.Saturday,
		&i.SaturdayFrom,
		&i.SaturdayTo,
		&i.Sunday,
		&i.SundayFrom,
		&i.SundayTo,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getEmployeeByEmail = `-- name: GetEmployeeByEmail :one
SELECT 
    e.id AS employee_id,
    e.first_name,
    e.last_name,
    s.department,
    s.designation
FROM HR_Employee e
INNER JOIN HR_EMP_Status s ON e.id = s.employee_id
WHERE e.email = ?
AND (e.is_ban = false OR e.is_ban IS NULL)
ORDER BY s.created_at DESC
LIMIT 1
`

type GetEmployeeByEmailRow struct {
	EmployeeID  int64  `json:"employee_id"`
	FirstName   string `json:"first_name"`
	LastName    string `json:"last_name"`
	Department  string `json:"department"`
	Designation string `json:"designation"`
}

func (q *Queries) GetEmployeeByEmail(ctx context.Context, email string) (GetEmployeeByEmailRow, error) {
	row := q.db.QueryRowContext(ctx, getEmployeeByEmail, email)
	var i GetEmployeeByEmailRow
	err := row.Scan(
		&i.EmployeeID,
		&i.FirstName,
		&i.LastName,
		&i.Department,
		&i.Designation,
	)
	return i, err
}

const getEmployeeIdByEmail = `-- name: GetEmployeeIdByEmail :one
SELECT employee_id FROM HR_EMP_User WHERE email = ?
`

func (q *Queries) GetEmployeeIdByEmail(ctx context.Context, email string) (int64, error) {
	row := q.db.QueryRowContext(ctx, getEmployeeIdByEmail, email)
	var employee_id int64
	err := row.Scan(&employee_id)
	return employee_id, err
}

const getEmployeeListWithWorkDays = `-- name: GetEmployeeListWithWorkDays :many
SELECT 
    e.id,
    e.first_name,
    e.last_name,
    u.email,
    -- Calculate base working days from weekly schedule (52 weeks)
    COALESCE(
        (CASE WHEN s.monday THEN 1 ELSE 0 END +
         CASE WHEN s.tuesday THEN 1 ELSE 0 END +
         CASE WHEN s.wednesday THEN 1 ELSE 0 END +
         CASE WHEN s.thursday THEN 1 ELSE 0 END +
         CASE WHEN s.friday THEN 1 ELSE 0 END +
         CASE WHEN s.saturday THEN 1 ELSE 0 END +
         CASE WHEN s.sunday THEN 1 ELSE 0 END) * 52, 0
    ) +
    -- Add additional working days for the specified year
    COALESCE(
        (SELECT COUNT(*) 
         FROM HR_EMP_SCHEDUAL_additional a 
         WHERE a.emp_id = e.id 
         AND YEAR(a.date) = ?
         AND a.from_time IS NOT NULL 
         AND a.to_time IS NOT NULL), 0
    ) as work_days_for_year
FROM HR_Employee e
LEFT JOIN HR_EMP_User u ON e.id = u.employee_id
LEFT JOIN HR_EMP_SCHEDUAL s ON e.id = s.emp_id
WHERE 
    (e.is_ban = false OR e.is_ban IS NULL)
    AND(? = '' OR e.first_name LIKE CONCAT('%', ?, '%'))
    AND (? = '' OR e.last_name LIKE CONCAT('%', ?, '%'))
    AND (? = '' OR u.email LIKE CONCAT('%', ?, '%'))
ORDER BY 
    CASE WHEN ? = 'first_name' THEN e.first_name END ASC,
    CASE WHEN ? = 'last_name' THEN e.last_name END ASC,
    CASE WHEN ? = 'email' THEN u.email END ASC,
    CASE WHEN ? = 'work_days' THEN work_days_for_year END ASC,
    e.id ASC
LIMIT ? OFFSET ?
`

type GetEmployeeListWithWorkDaysParams struct {
	Date     time.Time   `json:"date"`
	Column2  interface{} `json:"column_2"`
	CONCAT   interface{} `json:"CONCAT"`
	Column4  interface{} `json:"column_4"`
	CONCAT_2 interface{} `json:"CONCAT_2"`
	Column6  interface{} `json:"column_6"`
	CONCAT_3 interface{} `json:"CONCAT_3"`
	Column8  interface{} `json:"column_8"`
	Column9  interface{} `json:"column_9"`
	Column10 interface{} `json:"column_10"`
	Column11 interface{} `json:"column_11"`
	Limit    int32       `json:"limit"`
	Offset   int32       `json:"offset"`
}

type GetEmployeeListWithWorkDaysRow struct {
	ID              int64          `json:"id"`
	FirstName       string         `json:"first_name"`
	LastName        string         `json:"last_name"`
	Email           sql.NullString `json:"email"`
	WorkDaysForYear int32          `json:"work_days_for_year"`
}

func (q *Queries) GetEmployeeListWithWorkDays(ctx context.Context, arg GetEmployeeListWithWorkDaysParams) ([]GetEmployeeListWithWorkDaysRow, error) {
	rows, err := q.db.QueryContext(ctx, getEmployeeListWithWorkDays,
		arg.Date,
		arg.Column2,
		arg.CONCAT,
		arg.Column4,
		arg.CONCAT_2,
		arg.Column6,
		arg.CONCAT_3,
		arg.Column8,
		arg.Column9,
		arg.Column10,
		arg.Column11,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEmployeeListWithWorkDaysRow
	for rows.Next() {
		var i GetEmployeeListWithWorkDaysRow
		if err := rows.Scan(
			&i.ID,
			&i.FirstName,
			&i.LastName,
			&i.Email,
			&i.WorkDaysForYear,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEmployeeWorkDaysBreakdown = `-- name: GetEmployeeWorkDaysBreakdown :one
SELECT 
    e.id,
    e.first_name,
    e.last_name,
    u.email,
    -- Weekly working days count
    COALESCE(
        (CASE WHEN s.monday THEN 1 ELSE 0 END +
         CASE WHEN s.tuesday THEN 1 ELSE 0 END +
         CASE WHEN s.wednesday THEN 1 ELSE 0 END +
         CASE WHEN s.thursday THEN 1 ELSE 0 END +
         CASE WHEN s.friday THEN 1 ELSE 0 END +
         CASE WHEN s.saturday THEN 1 ELSE 0 END +
         CASE WHEN s.sunday THEN 1 ELSE 0 END), 0
    ) as weekly_work_days,
    -- Base yearly working days (weekly * 52)
    COALESCE(
        (CASE WHEN s.monday THEN 1 ELSE 0 END +
         CASE WHEN s.tuesday THEN 1 ELSE 0 END +
         CASE WHEN s.wednesday THEN 1 ELSE 0 END +
         CASE WHEN s.thursday THEN 1 ELSE 0 END +
         CASE WHEN s.friday THEN 1 ELSE 0 END +
         CASE WHEN s.saturday THEN 1 ELSE 0 END +
         CASE WHEN s.sunday THEN 1 ELSE 0 END) * 52, 0
    ) as base_yearly_days,
    -- Additional working days for the year
    COALESCE(
        (SELECT COUNT(*) 
         FROM HR_EMP_SCHEDUAL_additional a 
         WHERE a.emp_id = e.id 
         AND YEAR(a.date) = ?
         AND a.from_time IS NOT NULL 
         AND a.to_time IS NOT NULL), 0
    ) as additional_days,
    -- Total work days for year
    COALESCE(
        (CASE WHEN s.monday THEN 1 ELSE 0 END +
         CASE WHEN s.tuesday THEN 1 ELSE 0 END +
         CASE WHEN s.wednesday THEN 1 ELSE 0 END +
         CASE WHEN s.thursday THEN 1 ELSE 0 END +
         CASE WHEN s.friday THEN 1 ELSE 0 END +
         CASE WHEN s.saturday THEN 1 ELSE 0 END +
         CASE WHEN s.sunday THEN 1 ELSE 0 END) * 52, 0
    ) +
    COALESCE(
        (SELECT COUNT(*) 
         FROM HR_EMP_SCHEDUAL_additional a 
         WHERE a.emp_id = e.id 
         AND YEAR(a.date) = ?
         AND a.from_time IS NOT NULL 
         AND a.to_time IS NOT NULL), 0
    ) as total_work_days_for_year
FROM HR_Employee e
LEFT JOIN HR_EMP_User u ON e.id = u.employee_id
LEFT JOIN HR_EMP_SCHEDUAL s ON e.id = s.emp_id
WHERE e.id = ?
`

type GetEmployeeWorkDaysBreakdownParams struct {
	Date   time.Time `json:"date"`
	Date_2 time.Time `json:"date_2"`
	ID     int64     `json:"id"`
}

type GetEmployeeWorkDaysBreakdownRow struct {
	ID                   int64          `json:"id"`
	FirstName            string         `json:"first_name"`
	LastName             string         `json:"last_name"`
	Email                sql.NullString `json:"email"`
	WeeklyWorkDays       interface{}    `json:"weekly_work_days"`
	BaseYearlyDays       interface{}    `json:"base_yearly_days"`
	AdditionalDays       interface{}    `json:"additional_days"`
	TotalWorkDaysForYear int32          `json:"total_work_days_for_year"`
}

func (q *Queries) GetEmployeeWorkDaysBreakdown(ctx context.Context, arg GetEmployeeWorkDaysBreakdownParams) (GetEmployeeWorkDaysBreakdownRow, error) {
	row := q.db.QueryRowContext(ctx, getEmployeeWorkDaysBreakdown, arg.Date, arg.Date_2, arg.ID)
	var i GetEmployeeWorkDaysBreakdownRow
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.WeeklyWorkDays,
		&i.BaseYearlyDays,
		&i.AdditionalDays,
		&i.TotalWorkDaysForYear,
	)
	return i, err
}

const getInsufficientAttendance = `-- name: GetInsufficientAttendance :many
SELECT date, emp_id, in_time, out_time, total_time, scheduled_time
FROM (
  SELECT
    DATE(a.create_date) as date,
    a.emp_id,
    TIME_FORMAT(MIN(CASE WHEN a.attendance_type = 'in' THEN TIME(a.create_date) END), '%H:%i:%s') as in_time,
    TIME_FORMAT(MAX(CASE WHEN a.attendance_type = 'out' THEN TIME(a.create_date) END), '%H:%i:%s') as out_time,
    CASE 
      WHEN MIN(CASE WHEN a.attendance_type = 'in' THEN TIME(a.create_date) END) IS NOT NULL 
           AND MAX(CASE WHEN a.attendance_type = 'out' THEN TIME(a.create_date) END) IS NOT NULL 
      THEN TIME_FORMAT(TIMEDIFF(
        MAX(CASE WHEN a.attendance_type = 'out' THEN TIME(a.create_date) END),
        MIN(CASE WHEN a.attendance_type = 'in' THEN TIME(a.create_date) END)
      ), '%H:%i:%s')
      ELSE NULL 
    END as total_time,
    TIME_FORMAT(TIMEDIFF(
      COALESCE(sa.to_time,
        CASE DAYOFWEEK(DATE(a.create_date))
          WHEN 1 THEN s.sunday_to
          WHEN 2 THEN s.monday_to
          WHEN 3 THEN s.tuesday_to
          WHEN 4 THEN s.wednesday_to
          WHEN 5 THEN s.thursday_to
          WHEN 6 THEN s.friday_to
          WHEN 7 THEN s.saturday_to
        END), 
      COALESCE(sa.from_time, 
        CASE DAYOFWEEK(DATE(a.create_date))
          WHEN 1 THEN s.sunday_from
          WHEN 2 THEN s.monday_from  
          WHEN 3 THEN s.tuesday_from
          WHEN 4 THEN s.wednesday_from
          WHEN 5 THEN s.thursday_from
          WHEN 6 THEN s.friday_from
          WHEN 7 THEN s.saturday_from
        END)
    ), '%H:%i:%s') as scheduled_time
  FROM HR_EMP_ATTENDANCE a
  LEFT JOIN HR_EMP_SCHEDUAL s ON a.emp_id = s.emp_id
  LEFT JOIN HR_EMP_SCHEDUAL_additional sa 
    ON a.emp_id = sa.emp_id 
    AND DATE(a.create_date) = sa.date
  WHERE 
    a.emp_id = ?
    AND (? IS NULL OR DATE(a.create_date) = ?)
  GROUP BY DATE(a.create_date), a.emp_id
) t
WHERE t.total_time < t.scheduled_time
ORDER BY t.date DESC
LIMIT ? OFFSET ?
`

type GetInsufficientAttendanceParams struct {
	EmpID      int64       `json:"emp_id"`
	Column2    interface{} `json:"column_2"`
	CreateDate time.Time   `json:"create_date"`
	Limit      int32       `json:"limit"`
	Offset     int32       `json:"offset"`
}

type GetInsufficientAttendanceRow struct {
	Date          time.Time `json:"date"`
	EmpID         int64     `json:"emp_id"`
	InTime        string    `json:"in_time"`
	OutTime       string    `json:"out_time"`
	TotalTime     string    `json:"total_time"`
	ScheduledTime string    `json:"scheduled_time"`
}

func (q *Queries) GetInsufficientAttendance(ctx context.Context, arg GetInsufficientAttendanceParams) ([]GetInsufficientAttendanceRow, error) {
	rows, err := q.db.QueryContext(ctx, getInsufficientAttendance,
		arg.EmpID,
		arg.Column2,
		arg.CreateDate,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetInsufficientAttendanceRow
	for rows.Next() {
		var i GetInsufficientAttendanceRow
		if err := rows.Scan(
			&i.Date,
			&i.EmpID,
			&i.InTime,
			&i.OutTime,
			&i.TotalTime,
			&i.ScheduledTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInsufficientAttendanceForAll = `-- name: GetInsufficientAttendanceForAll :many
SELECT date, emp_id, name, in_time, out_time, total_time, scheduled_time
FROM (
  SELECT
    DATE(a.create_date) as date,
    a.emp_id,
    CONCAT(e.first_name, ' ', e.last_name) as name,
    TIME_FORMAT(MIN(CASE WHEN a.attendance_type = 'in' THEN TIME(a.create_date) END), '%H:%i:%s') as in_time,
    TIME_FORMAT(MAX(CASE WHEN a.attendance_type = 'out' THEN TIME(a.create_date) END), '%H:%i:%s') as out_time,
    CASE 
      WHEN MIN(CASE WHEN a.attendance_type = 'in' THEN TIME(a.create_date) END) IS NOT NULL 
           AND MAX(CASE WHEN a.attendance_type = 'out' THEN TIME(a.create_date) END) IS NOT NULL 
      THEN TIME_FORMAT(TIMEDIFF(
        MAX(CASE WHEN a.attendance_type = 'out' THEN TIME(a.create_date) END),
        MIN(CASE WHEN a.attendance_type = 'in' THEN TIME(a.create_date) END)
      ), '%H:%i:%s')
      ELSE NULL 
    END as total_time,
    TIME_FORMAT(TIMEDIFF(
      COALESCE(sa.to_time,
        CASE DAYOFWEEK(DATE(a.create_date))
          WHEN 1 THEN s.sunday_to
          WHEN 2 THEN s.monday_to
          WHEN 3 THEN s.tuesday_to
          WHEN 4 THEN s.wednesday_to
          WHEN 5 THEN s.thursday_to
          WHEN 6 THEN s.friday_to
          WHEN 7 THEN s.saturday_to
        END), 
      COALESCE(sa.from_time, 
        CASE DAYOFWEEK(DATE(a.create_date))
          WHEN 1 THEN s.sunday_from
          WHEN 2 THEN s.monday_from  
          WHEN 3 THEN s.tuesday_from
          WHEN 4 THEN s.wednesday_from
          WHEN 5 THEN s.thursday_from
          WHEN 6 THEN s.friday_from
          WHEN 7 THEN s.saturday_from
        END)
    ), '%H:%i:%s') as scheduled_time
  FROM HR_EMP_ATTENDANCE a
  LEFT JOIN HR_EMP_SCHEDUAL s ON a.emp_id = s.emp_id
  LEFT JOIN HR_Employee e ON a.emp_id = e.id
  LEFT JOIN HR_EMP_SCHEDUAL_additional sa 
    ON a.emp_id = sa.emp_id 
    AND DATE(a.create_date) = sa.date
  WHERE (? IS NULL OR DATE(a.create_date) = ?)
  GROUP BY DATE(a.create_date), a.emp_id
) t
WHERE t.total_time < t.scheduled_time
ORDER BY t.date DESC
LIMIT ? OFFSET ?
`

type GetInsufficientAttendanceForAllParams struct {
	Column1    interface{} `json:"column_1"`
	CreateDate time.Time   `json:"create_date"`
	Limit      int32       `json:"limit"`
	Offset     int32       `json:"offset"`
}

type GetInsufficientAttendanceForAllRow struct {
	Date          time.Time `json:"date"`
	EmpID         int64     `json:"emp_id"`
	Name          string    `json:"name"`
	InTime        string    `json:"in_time"`
	OutTime       string    `json:"out_time"`
	TotalTime     string    `json:"total_time"`
	ScheduledTime string    `json:"scheduled_time"`
}

func (q *Queries) GetInsufficientAttendanceForAll(ctx context.Context, arg GetInsufficientAttendanceForAllParams) ([]GetInsufficientAttendanceForAllRow, error) {
	rows, err := q.db.QueryContext(ctx, getInsufficientAttendanceForAll,
		arg.Column1,
		arg.CreateDate,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetInsufficientAttendanceForAllRow
	for rows.Next() {
		var i GetInsufficientAttendanceForAllRow
		if err := rows.Scan(
			&i.Date,
			&i.EmpID,
			&i.Name,
			&i.InTime,
			&i.OutTime,
			&i.TotalTime,
			&i.ScheduledTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLateAttendance = `-- name: GetLateAttendance :many
SELECT date, emp_id, in_time, out_time, total_time, first_in_time, scheduled_in_time
FROM (
  SELECT
    DATE(a.create_date) as date,
    a.emp_id,
    TIME_FORMAT(MIN(CASE WHEN a.attendance_type = 'in' THEN TIME(a.create_date) END), '%H:%i:%s') as in_time,
    TIME_FORMAT(MAX(CASE WHEN a.attendance_type = 'out' THEN TIME(a.create_date) END), '%H:%i:%s') as out_time,
    TIME_FORMAT(TIMEDIFF(
      MAX(CASE WHEN a.attendance_type = 'out' THEN TIME(a.create_date) END),
      MIN(CASE WHEN a.attendance_type = 'in' THEN TIME(a.create_date) END)
    ), '%H:%i:%s') as total_time,
    TIME_FORMAT(MIN(CASE WHEN a.attendance_type = 'in' THEN TIME(a.create_date) END), '%H:%i:%s') as first_in_time,
    TIME_FORMAT(COALESCE(sa.from_time, 
      CASE DAYOFWEEK(DATE(a.create_date))
        WHEN 1 THEN s.sunday_from
        WHEN 2 THEN s.monday_from  
        WHEN 3 THEN s.tuesday_from
        WHEN 4 THEN s.wednesday_from
        WHEN 5 THEN s.thursday_from
        WHEN 6 THEN s.friday_from
        WHEN 7 THEN s.saturday_from
      END
    ), '%H:%i:%s') as scheduled_in_time
  FROM HR_EMP_ATTENDANCE a
  LEFT JOIN HR_EMP_SCHEDUAL s ON a.emp_id = s.emp_id
  LEFT JOIN HR_EMP_SCHEDUAL_additional sa 
    ON a.emp_id = sa.emp_id 
    AND DATE(a.create_date) = sa.date
  WHERE a.emp_id = ?  -- specific employee
    AND (? IS NULL OR DATE(a.create_date) = ?) -- optional date filter
  GROUP BY DATE(a.create_date), a.emp_id
) t
WHERE t.first_in_time > t.scheduled_in_time
ORDER BY t.date DESC
LIMIT ? OFFSET ?
`

type GetLateAttendanceParams struct {
	EmpID      int64       `json:"emp_id"`
	Column2    interface{} `json:"column_2"`
	CreateDate time.Time   `json:"create_date"`
	Limit      int32       `json:"limit"`
	Offset     int32       `json:"offset"`
}

type GetLateAttendanceRow struct {
	Date            time.Time `json:"date"`
	EmpID           int64     `json:"emp_id"`
	InTime          string    `json:"in_time"`
	OutTime         string    `json:"out_time"`
	TotalTime       string    `json:"total_time"`
	FirstInTime     string    `json:"first_in_time"`
	ScheduledInTime string    `json:"scheduled_in_time"`
}

func (q *Queries) GetLateAttendance(ctx context.Context, arg GetLateAttendanceParams) ([]GetLateAttendanceRow, error) {
	rows, err := q.db.QueryContext(ctx, getLateAttendance,
		arg.EmpID,
		arg.Column2,
		arg.CreateDate,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLateAttendanceRow
	for rows.Next() {
		var i GetLateAttendanceRow
		if err := rows.Scan(
			&i.Date,
			&i.EmpID,
			&i.InTime,
			&i.OutTime,
			&i.TotalTime,
			&i.FirstInTime,
			&i.ScheduledInTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLateAttendanceForAll = `-- name: GetLateAttendanceForAll :many
SELECT date, emp_id, name, in_time, out_time, total_time, first_in_time, scheduled_in_time
FROM (
  SELECT
    DATE(a.create_date) as date,
    a.emp_id,
    CONCAT(e.first_name, ' ', e.last_name) as name,
    TIME_FORMAT(MIN(CASE WHEN a.attendance_type = 'in' THEN TIME(a.create_date) END), '%H:%i:%s') as in_time,
    TIME_FORMAT(MAX(CASE WHEN a.attendance_type = 'out' THEN TIME(a.create_date) END), '%H:%i:%s') as out_time,
    TIME_FORMAT(TIMEDIFF(
      MAX(CASE WHEN a.attendance_type = 'out' THEN TIME(a.create_date) END),
      MIN(CASE WHEN a.attendance_type = 'in' THEN TIME(a.create_date) END)
    ), '%H:%i:%s') as total_time,
    TIME_FORMAT(MIN(CASE WHEN a.attendance_type = 'in' THEN TIME(a.create_date) END), '%H:%i:%s') as first_in_time,
    TIME_FORMAT(COALESCE(sa.from_time, 
      CASE DAYOFWEEK(DATE(a.create_date))
        WHEN 1 THEN s.sunday_from
        WHEN 2 THEN s.monday_from  
        WHEN 3 THEN s.tuesday_from
        WHEN 4 THEN s.wednesday_from
        WHEN 5 THEN s.thursday_from
        WHEN 6 THEN s.friday_from
        WHEN 7 THEN s.saturday_from
      END
    ), '%H:%i:%s') as scheduled_in_time
  FROM HR_EMP_ATTENDANCE a
  LEFT JOIN HR_EMP_SCHEDUAL s ON a.emp_id = s.emp_id
  LEFT JOIN HR_Employee e ON a.emp_id = e.id
  LEFT JOIN HR_EMP_SCHEDUAL_additional sa 
    ON a.emp_id = sa.emp_id 
    AND DATE(a.create_date) = sa.date
  WHERE (? IS NULL OR DATE(a.create_date) = ?) -- optional date filter
  GROUP BY DATE(a.create_date), a.emp_id
) t
WHERE t.first_in_time > t.scheduled_in_time
ORDER BY t.date DESC
LIMIT ? OFFSET ?
`

type GetLateAttendanceForAllParams struct {
	Column1    interface{} `json:"column_1"`
	CreateDate time.Time   `json:"create_date"`
	Limit      int32       `json:"limit"`
	Offset     int32       `json:"offset"`
}

type GetLateAttendanceForAllRow struct {
	Date            time.Time `json:"date"`
	EmpID           int64     `json:"emp_id"`
	Name            string    `json:"name"`
	InTime          string    `json:"in_time"`
	OutTime         string    `json:"out_time"`
	TotalTime       string    `json:"total_time"`
	FirstInTime     string    `json:"first_in_time"`
	ScheduledInTime string    `json:"scheduled_in_time"`
}

func (q *Queries) GetLateAttendanceForAll(ctx context.Context, arg GetLateAttendanceForAllParams) ([]GetLateAttendanceForAllRow, error) {
	rows, err := q.db.QueryContext(ctx, getLateAttendanceForAll,
		arg.Column1,
		arg.CreateDate,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLateAttendanceForAllRow
	for rows.Next() {
		var i GetLateAttendanceForAllRow
		if err := rows.Scan(
			&i.Date,
			&i.EmpID,
			&i.Name,
			&i.InTime,
			&i.OutTime,
			&i.TotalTime,
			&i.FirstInTime,
			&i.ScheduledInTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNormalAttendance = `-- name: GetNormalAttendance :many
SELECT date, emp_id, in_time, out_time, total_time, scheduled_time
FROM (
  SELECT
    DATE(a.create_date) as date,
    a.emp_id,
    TIME_FORMAT(MIN(CASE WHEN a.attendance_type = 'in' THEN TIME(a.create_date) END), '%H:%i:%s') as in_time,
    TIME_FORMAT(MAX(CASE WHEN a.attendance_type = 'out' THEN TIME(a.create_date) END), '%H:%i:%s') as out_time,
    CASE 
      WHEN MIN(CASE WHEN a.attendance_type = 'in' THEN TIME(a.create_date) END) IS NOT NULL 
           AND MAX(CASE WHEN a.attendance_type = 'out' THEN TIME(a.create_date) END) IS NOT NULL 
      THEN TIME_FORMAT(TIMEDIFF(
        MAX(CASE WHEN a.attendance_type = 'out' THEN TIME(a.create_date) END),
        MIN(CASE WHEN a.attendance_type = 'in' THEN TIME(a.create_date) END)
      ), '%H:%i:%s')
      ELSE NULL 
    END as total_time,
    TIME_FORMAT(TIMEDIFF(
      COALESCE(sa.to_time,
        CASE DAYOFWEEK(DATE(a.create_date))
          WHEN 1 THEN s.sunday_to
          WHEN 2 THEN s.monday_to
          WHEN 3 THEN s.tuesday_to
          WHEN 4 THEN s.wednesday_to
          WHEN 5 THEN s.thursday_to
          WHEN 6 THEN s.friday_to
          WHEN 7 THEN s.saturday_to
        END), 
      COALESCE(sa.from_time, 
        CASE DAYOFWEEK(DATE(a.create_date))
          WHEN 1 THEN s.sunday_from
          WHEN 2 THEN s.monday_from  
          WHEN 3 THEN s.tuesday_from
          WHEN 4 THEN s.wednesday_from
          WHEN 5 THEN s.thursday_from
          WHEN 6 THEN s.friday_from
          WHEN 7 THEN s.saturday_from
        END)
    ), '%H:%i:%s') as scheduled_time
  FROM HR_EMP_ATTENDANCE a
  LEFT JOIN HR_EMP_SCHEDUAL s ON a.emp_id = s.emp_id
  LEFT JOIN HR_EMP_SCHEDUAL_additional sa 
    ON a.emp_id = sa.emp_id 
    AND DATE(a.create_date) = sa.date
  WHERE 
    a.emp_id = ?
    AND (? IS NULL OR DATE(a.create_date) = ?)
  GROUP BY DATE(a.create_date), a.emp_id
) t
WHERE t.total_time = t.scheduled_time
ORDER BY t.date DESC
LIMIT ? OFFSET ?
`

type GetNormalAttendanceParams struct {
	EmpID      int64       `json:"emp_id"`
	Column2    interface{} `json:"column_2"`
	CreateDate time.Time   `json:"create_date"`
	Limit      int32       `json:"limit"`
	Offset     int32       `json:"offset"`
}

type GetNormalAttendanceRow struct {
	Date          time.Time `json:"date"`
	EmpID         int64     `json:"emp_id"`
	InTime        string    `json:"in_time"`
	OutTime       string    `json:"out_time"`
	TotalTime     string    `json:"total_time"`
	ScheduledTime string    `json:"scheduled_time"`
}

func (q *Queries) GetNormalAttendance(ctx context.Context, arg GetNormalAttendanceParams) ([]GetNormalAttendanceRow, error) {
	rows, err := q.db.QueryContext(ctx, getNormalAttendance,
		arg.EmpID,
		arg.Column2,
		arg.CreateDate,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetNormalAttendanceRow
	for rows.Next() {
		var i GetNormalAttendanceRow
		if err := rows.Scan(
			&i.Date,
			&i.EmpID,
			&i.InTime,
			&i.OutTime,
			&i.TotalTime,
			&i.ScheduledTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNormalAttendanceForAll = `-- name: GetNormalAttendanceForAll :many
SELECT date, emp_id, name, in_time, out_time, total_time, scheduled_time
FROM (
  SELECT
    DATE(a.create_date) as date,
    a.emp_id,
    CONCAT(e.first_name, ' ', e.last_name) as name,
    TIME_FORMAT(MIN(CASE WHEN a.attendance_type = 'in' THEN TIME(a.create_date) END), '%H:%i:%s') as in_time,
    TIME_FORMAT(MAX(CASE WHEN a.attendance_type = 'out' THEN TIME(a.create_date) END), '%H:%i:%s') as out_time,
    CASE 
      WHEN MIN(CASE WHEN a.attendance_type = 'in' THEN TIME(a.create_date) END) IS NOT NULL 
           AND MAX(CASE WHEN a.attendance_type = 'out' THEN TIME(a.create_date) END) IS NOT NULL 
      THEN TIME_FORMAT(TIMEDIFF(
        MAX(CASE WHEN a.attendance_type = 'out' THEN TIME(a.create_date) END),
        MIN(CASE WHEN a.attendance_type = 'in' THEN TIME(a.create_date) END)
      ), '%H:%i:%s')
      ELSE NULL 
    END as total_time,
    TIME_FORMAT(TIMEDIFF(
      COALESCE(sa.to_time,
        CASE DAYOFWEEK(DATE(a.create_date))
          WHEN 1 THEN s.sunday_to
          WHEN 2 THEN s.monday_to
          WHEN 3 THEN s.tuesday_to
          WHEN 4 THEN s.wednesday_to
          WHEN 5 THEN s.thursday_to
          WHEN 6 THEN s.friday_to
          WHEN 7 THEN s.saturday_to
        END), 
      COALESCE(sa.from_time, 
        CASE DAYOFWEEK(DATE(a.create_date))
          WHEN 1 THEN s.sunday_from
          WHEN 2 THEN s.monday_from  
          WHEN 3 THEN s.tuesday_from
          WHEN 4 THEN s.wednesday_from
          WHEN 5 THEN s.thursday_from
          WHEN 6 THEN s.friday_from
          WHEN 7 THEN s.saturday_from
        END)
    ), '%H:%i:%s') as scheduled_time
  FROM HR_EMP_ATTENDANCE a
  LEFT JOIN HR_EMP_SCHEDUAL s ON a.emp_id = s.emp_id
  LEFT JOIN HR_Employee e ON a.emp_id = e.id
  LEFT JOIN HR_EMP_SCHEDUAL_additional sa 
    ON a.emp_id = sa.emp_id 
    AND DATE(a.create_date) = sa.date
  WHERE  (? IS NULL OR DATE(a.create_date) = ?)
  GROUP BY DATE(a.create_date), a.emp_id
) t
WHERE t.total_time = t.scheduled_time
ORDER BY t.date DESC
LIMIT ? OFFSET ?
`

type GetNormalAttendanceForAllParams struct {
	Column1    interface{} `json:"column_1"`
	CreateDate time.Time   `json:"create_date"`
	Limit      int32       `json:"limit"`
	Offset     int32       `json:"offset"`
}

type GetNormalAttendanceForAllRow struct {
	Date          time.Time `json:"date"`
	EmpID         int64     `json:"emp_id"`
	Name          string    `json:"name"`
	InTime        string    `json:"in_time"`
	OutTime       string    `json:"out_time"`
	TotalTime     string    `json:"total_time"`
	ScheduledTime string    `json:"scheduled_time"`
}

func (q *Queries) GetNormalAttendanceForAll(ctx context.Context, arg GetNormalAttendanceForAllParams) ([]GetNormalAttendanceForAllRow, error) {
	rows, err := q.db.QueryContext(ctx, getNormalAttendanceForAll,
		arg.Column1,
		arg.CreateDate,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetNormalAttendanceForAllRow
	for rows.Next() {
		var i GetNormalAttendanceForAllRow
		if err := rows.Scan(
			&i.Date,
			&i.EmpID,
			&i.Name,
			&i.InTime,
			&i.OutTime,
			&i.TotalTime,
			&i.ScheduledTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAdditionalSchedule = `-- name: UpdateAdditionalSchedule :exec
UPDATE HR_EMP_SCHEDUAL_additional 
SET from_time = ?, to_time = ?
WHERE emp_id = ? AND date = ?
`

type UpdateAdditionalScheduleParams struct {
	FromTime sql.NullTime `json:"from_time"`
	ToTime   sql.NullTime `json:"to_time"`
	EmpID    int64        `json:"emp_id"`
	Date     time.Time    `json:"date"`
}

func (q *Queries) UpdateAdditionalSchedule(ctx context.Context, arg UpdateAdditionalScheduleParams) error {
	_, err := q.db.ExecContext(ctx, updateAdditionalSchedule,
		arg.FromTime,
		arg.ToTime,
		arg.EmpID,
		arg.Date,
	)
	return err
}

const updateEmployeeSchedule = `-- name: UpdateEmployeeSchedule :exec
UPDATE HR_EMP_SCHEDUAL SET
    monday = ?, monday_from = ?, monday_to = ?,
    tuesday = ?, tuesday_from = ?, tuesday_to = ?,
    wednesday = ?, wednesday_from = ?, wednesday_to = ?,
    thursday = ?, thursday_from = ?, thursday_to = ?,
    friday = ?, friday_from = ?, friday_to = ?,
    saturday = ?, saturday_from = ?, saturday_to = ?,
    sunday = ?, sunday_from = ?, sunday_to = ?
WHERE emp_id = ?
`

type UpdateEmployeeScheduleParams struct {
	Monday        sql.NullBool `json:"monday"`
	MondayFrom    sql.NullTime `json:"monday_from"`
	MondayTo      sql.NullTime `json:"monday_to"`
	Tuesday       sql.NullBool `json:"tuesday"`
	TuesdayFrom   sql.NullTime `json:"tuesday_from"`
	TuesdayTo     sql.NullTime `json:"tuesday_to"`
	Wednesday     sql.NullBool `json:"wednesday"`
	WednesdayFrom sql.NullTime `json:"wednesday_from"`
	WednesdayTo   sql.NullTime `json:"wednesday_to"`
	Thursday      sql.NullBool `json:"thursday"`
	ThursdayFrom  sql.NullTime `json:"thursday_from"`
	ThursdayTo    sql.NullTime `json:"thursday_to"`
	Friday        sql.NullBool `json:"friday"`
	FridayFrom    sql.NullTime `json:"friday_from"`
	FridayTo      sql.NullTime `json:"friday_to"`
	Saturday      sql.NullBool `json:"saturday"`
	SaturdayFrom  sql.NullTime `json:"saturday_from"`
	SaturdayTo    sql.NullTime `json:"saturday_to"`
	Sunday        sql.NullBool `json:"sunday"`
	SundayFrom    sql.NullTime `json:"sunday_from"`
	SundayTo      sql.NullTime `json:"sunday_to"`
	EmpID         int64        `json:"emp_id"`
}

func (q *Queries) UpdateEmployeeSchedule(ctx context.Context, arg UpdateEmployeeScheduleParams) error {
	_, err := q.db.ExecContext(ctx, updateEmployeeSchedule,
		arg.Monday,
		arg.MondayFrom,
		arg.MondayTo,
		arg.Tuesday,
		arg.TuesdayFrom,
		arg.TuesdayTo,
		arg.Wednesday,
		arg.WednesdayFrom,
		arg.WednesdayTo,
		arg.Thursday,
		arg.ThursdayFrom,
		arg.ThursdayTo,
		arg.Friday,
		arg.FridayFrom,
		arg.FridayTo,
		arg.Saturday,
		arg.SaturdayFrom,
		arg.SaturdayTo,
		arg.Sunday,
		arg.SundayFrom,
		arg.SundayTo,
		arg.EmpID,
	)
	return err
}
