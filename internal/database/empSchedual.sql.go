// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: empSchedual.sql

package database

import (
	"context"
	"database/sql"
	"time"
)

const countEmployeesWithFilters = `-- name: CountEmployeesWithFilters :one
SELECT COUNT(*) as total
FROM HR_Employee e
LEFT JOIN HR_EMP_User u ON e.id = u.employee_id
WHERE 
    (? = '' OR e.first_name LIKE CONCAT('%', ?, '%'))
    AND (? = '' OR e.last_name LIKE CONCAT('%', ?, '%'))
    AND (? = '' OR u.email LIKE CONCAT('%', ?, '%'))
`

type CountEmployeesWithFiltersParams struct {
	Column1  interface{} `json:"column_1"`
	CONCAT   interface{} `json:"CONCAT"`
	Column3  interface{} `json:"column_3"`
	CONCAT_2 interface{} `json:"CONCAT_2"`
	Column5  interface{} `json:"column_5"`
	CONCAT_3 interface{} `json:"CONCAT_3"`
}

// Count total employees for pagination (with same filters)
func (q *Queries) CountEmployeesWithFilters(ctx context.Context, arg CountEmployeesWithFiltersParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countEmployeesWithFilters,
		arg.Column1,
		arg.CONCAT,
		arg.Column3,
		arg.CONCAT_2,
		arg.Column5,
		arg.CONCAT_3,
	)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const createAdditionalSchedule = `-- name: CreateAdditionalSchedule :exec
INSERT INTO HR_EMP_SCHEDUAL_additional (emp_id, date, from_time, to_time)
VALUES (?, ?, ?, ?)
`

type CreateAdditionalScheduleParams struct {
	EmpID    int64        `json:"emp_id"`
	Date     time.Time    `json:"date"`
	FromTime sql.NullTime `json:"from_time"`
	ToTime   sql.NullTime `json:"to_time"`
}

func (q *Queries) CreateAdditionalSchedule(ctx context.Context, arg CreateAdditionalScheduleParams) error {
	_, err := q.db.ExecContext(ctx, createAdditionalSchedule,
		arg.EmpID,
		arg.Date,
		arg.FromTime,
		arg.ToTime,
	)
	return err
}

const createEmployeeSchedule = `-- name: CreateEmployeeSchedule :exec
INSERT INTO HR_EMP_SCHEDUAL (
    emp_id, monday, monday_from, monday_to,
    tuesday, tuesday_from, tuesday_to,
    wednesday, wednesday_from, wednesday_to,
    thursday, thursday_from, thursday_to,
    friday, friday_from, friday_to,
    saturday, saturday_from, saturday_to,
    sunday, sunday_from, sunday_to
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateEmployeeScheduleParams struct {
	EmpID         int64        `json:"emp_id"`
	Monday        sql.NullBool `json:"monday"`
	MondayFrom    sql.NullTime `json:"monday_from"`
	MondayTo      sql.NullTime `json:"monday_to"`
	Tuesday       sql.NullBool `json:"tuesday"`
	TuesdayFrom   sql.NullTime `json:"tuesday_from"`
	TuesdayTo     sql.NullTime `json:"tuesday_to"`
	Wednesday     sql.NullBool `json:"wednesday"`
	WednesdayFrom sql.NullTime `json:"wednesday_from"`
	WednesdayTo   sql.NullTime `json:"wednesday_to"`
	Thursday      sql.NullBool `json:"thursday"`
	ThursdayFrom  sql.NullTime `json:"thursday_from"`
	ThursdayTo    sql.NullTime `json:"thursday_to"`
	Friday        sql.NullBool `json:"friday"`
	FridayFrom    sql.NullTime `json:"friday_from"`
	FridayTo      sql.NullTime `json:"friday_to"`
	Saturday      sql.NullBool `json:"saturday"`
	SaturdayFrom  sql.NullTime `json:"saturday_from"`
	SaturdayTo    sql.NullTime `json:"saturday_to"`
	Sunday        sql.NullBool `json:"sunday"`
	SundayFrom    sql.NullTime `json:"sunday_from"`
	SundayTo      sql.NullTime `json:"sunday_to"`
}

func (q *Queries) CreateEmployeeSchedule(ctx context.Context, arg CreateEmployeeScheduleParams) error {
	_, err := q.db.ExecContext(ctx, createEmployeeSchedule,
		arg.EmpID,
		arg.Monday,
		arg.MondayFrom,
		arg.MondayTo,
		arg.Tuesday,
		arg.TuesdayFrom,
		arg.TuesdayTo,
		arg.Wednesday,
		arg.WednesdayFrom,
		arg.WednesdayTo,
		arg.Thursday,
		arg.ThursdayFrom,
		arg.ThursdayTo,
		arg.Friday,
		arg.FridayFrom,
		arg.FridayTo,
		arg.Saturday,
		arg.SaturdayFrom,
		arg.SaturdayTo,
		arg.Sunday,
		arg.SundayFrom,
		arg.SundayTo,
	)
	return err
}

const deleteAdditionalSchedule = `-- name: DeleteAdditionalSchedule :exec
DELETE FROM HR_EMP_SCHEDUAL_additional WHERE emp_id = ? AND date = ?
`

type DeleteAdditionalScheduleParams struct {
	EmpID int64     `json:"emp_id"`
	Date  time.Time `json:"date"`
}

func (q *Queries) DeleteAdditionalSchedule(ctx context.Context, arg DeleteAdditionalScheduleParams) error {
	_, err := q.db.ExecContext(ctx, deleteAdditionalSchedule, arg.EmpID, arg.Date)
	return err
}

const deleteAllAdditionalSchedules = `-- name: DeleteAllAdditionalSchedules :exec
DELETE FROM HR_EMP_SCHEDUAL_additional WHERE emp_id = ?
`

func (q *Queries) DeleteAllAdditionalSchedules(ctx context.Context, empID int64) error {
	_, err := q.db.ExecContext(ctx, deleteAllAdditionalSchedules, empID)
	return err
}

const deleteEmployeeSchedule = `-- name: DeleteEmployeeSchedule :exec
DELETE FROM HR_EMP_SCHEDUAL WHERE emp_id = ?
`

func (q *Queries) DeleteEmployeeSchedule(ctx context.Context, empID int64) error {
	_, err := q.db.ExecContext(ctx, deleteEmployeeSchedule, empID)
	return err
}

const getEmployeeByEmail = `-- name: GetEmployeeByEmail :one
SELECT 
    e.id AS employee_id,
    e.first_name,
    e.last_name,
    s.department,
    s.designation
FROM HR_Employee e
INNER JOIN HR_EMP_Status s ON e.id = s.employee_id
WHERE e.email = ?
ORDER BY s.created_at DESC
LIMIT 1
`

type GetEmployeeByEmailRow struct {
	EmployeeID  int64  `json:"employee_id"`
	FirstName   string `json:"first_name"`
	LastName    string `json:"last_name"`
	Department  string `json:"department"`
	Designation string `json:"designation"`
}

func (q *Queries) GetEmployeeByEmail(ctx context.Context, email string) (GetEmployeeByEmailRow, error) {
	row := q.db.QueryRowContext(ctx, getEmployeeByEmail, email)
	var i GetEmployeeByEmailRow
	err := row.Scan(
		&i.EmployeeID,
		&i.FirstName,
		&i.LastName,
		&i.Department,
		&i.Designation,
	)
	return i, err
}

const getEmployeeIdByEmail = `-- name: GetEmployeeIdByEmail :one
SELECT employee_id FROM HR_EMP_User WHERE email = ?
`

func (q *Queries) GetEmployeeIdByEmail(ctx context.Context, email string) (int64, error) {
	row := q.db.QueryRowContext(ctx, getEmployeeIdByEmail, email)
	var employee_id int64
	err := row.Scan(&employee_id)
	return employee_id, err
}

const getEmployeeListWithWorkDays = `-- name: GetEmployeeListWithWorkDays :many
SELECT 
    e.id,
    e.first_name,
    e.last_name,
    u.email,
    -- Calculate base working days from weekly schedule (52 weeks)
    COALESCE(
        (CASE WHEN s.monday THEN 1 ELSE 0 END +
         CASE WHEN s.tuesday THEN 1 ELSE 0 END +
         CASE WHEN s.wednesday THEN 1 ELSE 0 END +
         CASE WHEN s.thursday THEN 1 ELSE 0 END +
         CASE WHEN s.friday THEN 1 ELSE 0 END +
         CASE WHEN s.saturday THEN 1 ELSE 0 END +
         CASE WHEN s.sunday THEN 1 ELSE 0 END) * 52, 0
    ) +
    -- Add additional working days for the specified year
    COALESCE(
        (SELECT COUNT(*) 
         FROM HR_EMP_SCHEDUAL_additional a 
         WHERE a.emp_id = e.id 
         AND YEAR(a.date) = ?
         AND a.from_time IS NOT NULL 
         AND a.to_time IS NOT NULL), 0
    ) as work_days_for_year
FROM HR_Employee e
LEFT JOIN HR_EMP_User u ON e.id = u.employee_id
LEFT JOIN HR_EMP_SCHEDUAL s ON e.id = s.emp_id
WHERE 
    (? = '' OR e.first_name LIKE CONCAT('%', ?, '%'))
    AND (? = '' OR e.last_name LIKE CONCAT('%', ?, '%'))
    AND (? = '' OR u.email LIKE CONCAT('%', ?, '%'))
ORDER BY 
    CASE WHEN ? = 'first_name' THEN e.first_name END ASC,
    CASE WHEN ? = 'last_name' THEN e.last_name END ASC,
    CASE WHEN ? = 'email' THEN u.email END ASC,
    CASE WHEN ? = 'work_days' THEN work_days_for_year END ASC,
    e.id ASC
LIMIT ? OFFSET ?
`

type GetEmployeeListWithWorkDaysParams struct {
	Date     time.Time   `json:"date"`
	Column2  interface{} `json:"column_2"`
	CONCAT   interface{} `json:"CONCAT"`
	Column4  interface{} `json:"column_4"`
	CONCAT_2 interface{} `json:"CONCAT_2"`
	Column6  interface{} `json:"column_6"`
	CONCAT_3 interface{} `json:"CONCAT_3"`
	Column8  interface{} `json:"column_8"`
	Column9  interface{} `json:"column_9"`
	Column10 interface{} `json:"column_10"`
	Column11 interface{} `json:"column_11"`
	Limit    int32       `json:"limit"`
	Offset   int32       `json:"offset"`
}

type GetEmployeeListWithWorkDaysRow struct {
	ID              int64          `json:"id"`
	FirstName       string         `json:"first_name"`
	LastName        string         `json:"last_name"`
	Email           sql.NullString `json:"email"`
	WorkDaysForYear int32          `json:"work_days_for_year"`
}

func (q *Queries) GetEmployeeListWithWorkDays(ctx context.Context, arg GetEmployeeListWithWorkDaysParams) ([]GetEmployeeListWithWorkDaysRow, error) {
	rows, err := q.db.QueryContext(ctx, getEmployeeListWithWorkDays,
		arg.Date,
		arg.Column2,
		arg.CONCAT,
		arg.Column4,
		arg.CONCAT_2,
		arg.Column6,
		arg.CONCAT_3,
		arg.Column8,
		arg.Column9,
		arg.Column10,
		arg.Column11,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEmployeeListWithWorkDaysRow
	for rows.Next() {
		var i GetEmployeeListWithWorkDaysRow
		if err := rows.Scan(
			&i.ID,
			&i.FirstName,
			&i.LastName,
			&i.Email,
			&i.WorkDaysForYear,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEmployeeWorkDaysBreakdown = `-- name: GetEmployeeWorkDaysBreakdown :one
SELECT 
    e.id,
    e.first_name,
    e.last_name,
    u.email,
    -- Weekly working days count
    COALESCE(
        (CASE WHEN s.monday THEN 1 ELSE 0 END +
         CASE WHEN s.tuesday THEN 1 ELSE 0 END +
         CASE WHEN s.wednesday THEN 1 ELSE 0 END +
         CASE WHEN s.thursday THEN 1 ELSE 0 END +
         CASE WHEN s.friday THEN 1 ELSE 0 END +
         CASE WHEN s.saturday THEN 1 ELSE 0 END +
         CASE WHEN s.sunday THEN 1 ELSE 0 END), 0
    ) as weekly_work_days,
    -- Base yearly working days (weekly * 52)
    COALESCE(
        (CASE WHEN s.monday THEN 1 ELSE 0 END +
         CASE WHEN s.tuesday THEN 1 ELSE 0 END +
         CASE WHEN s.wednesday THEN 1 ELSE 0 END +
         CASE WHEN s.thursday THEN 1 ELSE 0 END +
         CASE WHEN s.friday THEN 1 ELSE 0 END +
         CASE WHEN s.saturday THEN 1 ELSE 0 END +
         CASE WHEN s.sunday THEN 1 ELSE 0 END) * 52, 0
    ) as base_yearly_days,
    -- Additional working days for the year
    COALESCE(
        (SELECT COUNT(*) 
         FROM HR_EMP_SCHEDUAL_additional a 
         WHERE a.emp_id = e.id 
         AND YEAR(a.date) = ?
         AND a.from_time IS NOT NULL 
         AND a.to_time IS NOT NULL), 0
    ) as additional_days,
    -- Total work days for year
    COALESCE(
        (CASE WHEN s.monday THEN 1 ELSE 0 END +
         CASE WHEN s.tuesday THEN 1 ELSE 0 END +
         CASE WHEN s.wednesday THEN 1 ELSE 0 END +
         CASE WHEN s.thursday THEN 1 ELSE 0 END +
         CASE WHEN s.friday THEN 1 ELSE 0 END +
         CASE WHEN s.saturday THEN 1 ELSE 0 END +
         CASE WHEN s.sunday THEN 1 ELSE 0 END) * 52, 0
    ) +
    COALESCE(
        (SELECT COUNT(*) 
         FROM HR_EMP_SCHEDUAL_additional a 
         WHERE a.emp_id = e.id 
         AND YEAR(a.date) = ?
         AND a.from_time IS NOT NULL 
         AND a.to_time IS NOT NULL), 0
    ) as total_work_days_for_year
FROM HR_Employee e
LEFT JOIN HR_EMP_User u ON e.id = u.employee_id
LEFT JOIN HR_EMP_SCHEDUAL s ON e.id = s.emp_id
WHERE e.id = ?
`

type GetEmployeeWorkDaysBreakdownParams struct {
	Date   time.Time `json:"date"`
	Date_2 time.Time `json:"date_2"`
	ID     int64     `json:"id"`
}

type GetEmployeeWorkDaysBreakdownRow struct {
	ID                   int64          `json:"id"`
	FirstName            string         `json:"first_name"`
	LastName             string         `json:"last_name"`
	Email                sql.NullString `json:"email"`
	WeeklyWorkDays       interface{}    `json:"weekly_work_days"`
	BaseYearlyDays       interface{}    `json:"base_yearly_days"`
	AdditionalDays       interface{}    `json:"additional_days"`
	TotalWorkDaysForYear int32          `json:"total_work_days_for_year"`
}

func (q *Queries) GetEmployeeWorkDaysBreakdown(ctx context.Context, arg GetEmployeeWorkDaysBreakdownParams) (GetEmployeeWorkDaysBreakdownRow, error) {
	row := q.db.QueryRowContext(ctx, getEmployeeWorkDaysBreakdown, arg.Date, arg.Date_2, arg.ID)
	var i GetEmployeeWorkDaysBreakdownRow
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.WeeklyWorkDays,
		&i.BaseYearlyDays,
		&i.AdditionalDays,
		&i.TotalWorkDaysForYear,
	)
	return i, err
}

const updateAdditionalSchedule = `-- name: UpdateAdditionalSchedule :exec
UPDATE HR_EMP_SCHEDUAL_additional 
SET from_time = ?, to_time = ?
WHERE emp_id = ? AND date = ?
`

type UpdateAdditionalScheduleParams struct {
	FromTime sql.NullTime `json:"from_time"`
	ToTime   sql.NullTime `json:"to_time"`
	EmpID    int64        `json:"emp_id"`
	Date     time.Time    `json:"date"`
}

func (q *Queries) UpdateAdditionalSchedule(ctx context.Context, arg UpdateAdditionalScheduleParams) error {
	_, err := q.db.ExecContext(ctx, updateAdditionalSchedule,
		arg.FromTime,
		arg.ToTime,
		arg.EmpID,
		arg.Date,
	)
	return err
}

const updateEmployeeSchedule = `-- name: UpdateEmployeeSchedule :exec
UPDATE HR_EMP_SCHEDUAL SET
    monday = ?, monday_from = ?, monday_to = ?,
    tuesday = ?, tuesday_from = ?, tuesday_to = ?,
    wednesday = ?, wednesday_from = ?, wednesday_to = ?,
    thursday = ?, thursday_from = ?, thursday_to = ?,
    friday = ?, friday_from = ?, friday_to = ?,
    saturday = ?, saturday_from = ?, saturday_to = ?,
    sunday = ?, sunday_from = ?, sunday_to = ?
WHERE emp_id = ?
`

type UpdateEmployeeScheduleParams struct {
	Monday        sql.NullBool `json:"monday"`
	MondayFrom    sql.NullTime `json:"monday_from"`
	MondayTo      sql.NullTime `json:"monday_to"`
	Tuesday       sql.NullBool `json:"tuesday"`
	TuesdayFrom   sql.NullTime `json:"tuesday_from"`
	TuesdayTo     sql.NullTime `json:"tuesday_to"`
	Wednesday     sql.NullBool `json:"wednesday"`
	WednesdayFrom sql.NullTime `json:"wednesday_from"`
	WednesdayTo   sql.NullTime `json:"wednesday_to"`
	Thursday      sql.NullBool `json:"thursday"`
	ThursdayFrom  sql.NullTime `json:"thursday_from"`
	ThursdayTo    sql.NullTime `json:"thursday_to"`
	Friday        sql.NullBool `json:"friday"`
	FridayFrom    sql.NullTime `json:"friday_from"`
	FridayTo      sql.NullTime `json:"friday_to"`
	Saturday      sql.NullBool `json:"saturday"`
	SaturdayFrom  sql.NullTime `json:"saturday_from"`
	SaturdayTo    sql.NullTime `json:"saturday_to"`
	Sunday        sql.NullBool `json:"sunday"`
	SundayFrom    sql.NullTime `json:"sunday_from"`
	SundayTo      sql.NullTime `json:"sunday_to"`
	EmpID         int64        `json:"emp_id"`
}

func (q *Queries) UpdateEmployeeSchedule(ctx context.Context, arg UpdateEmployeeScheduleParams) error {
	_, err := q.db.ExecContext(ctx, updateEmployeeSchedule,
		arg.Monday,
		arg.MondayFrom,
		arg.MondayTo,
		arg.Tuesday,
		arg.TuesdayFrom,
		arg.TuesdayTo,
		arg.Wednesday,
		arg.WednesdayFrom,
		arg.WednesdayTo,
		arg.Thursday,
		arg.ThursdayFrom,
		arg.ThursdayTo,
		arg.Friday,
		arg.FridayFrom,
		arg.FridayTo,
		arg.Saturday,
		arg.SaturdayFrom,
		arg.SaturdayTo,
		arg.Sunday,
		arg.SundayFrom,
		arg.SundayTo,
		arg.EmpID,
	)
	return err
}
