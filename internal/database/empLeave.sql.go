// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: empLeave.sql

package database

import (
	"context"
	"database/sql"
	"time"
)

const checkLeaveCountForYear = `-- name: CheckLeaveCountForYear :one
SELECT 
    COALESCE(COUNT(*), 0) as used_leaves,
    COALESCE(b.leave_count, 0) as total_allowed
FROM HR_EMP_LEAVES l
RIGHT JOIN HR_EMP_Benifits b ON l.emp_id = b.employee_id 
    AND l.leave_type = b.leave_type
WHERE b.employee_id = ? 
    AND b.leave_type = ? 
    AND b.leave_status = 1
    AND (l.leave_date IS NULL OR YEAR(l.leave_date) = YEAR(CURDATE()))
`

type CheckLeaveCountForYearParams struct {
	EmployeeID int64  `json:"employee_id"`
	LeaveType  string `json:"leave_type"`
}

type CheckLeaveCountForYearRow struct {
	UsedLeaves   interface{} `json:"used_leaves"`
	TotalAllowed int32       `json:"total_allowed"`
}

func (q *Queries) CheckLeaveCountForYear(ctx context.Context, arg CheckLeaveCountForYearParams) (CheckLeaveCountForYearRow, error) {
	row := q.db.QueryRowContext(ctx, checkLeaveCountForYear, arg.EmployeeID, arg.LeaveType)
	var i CheckLeaveCountForYearRow
	err := row.Scan(&i.UsedLeaves, &i.TotalAllowed)
	return i, err
}

const createLeave = `-- name: CreateLeave :exec
INSERT INTO HR_EMP_LEAVES (emp_id, leave_type, leave_date, reason, added_by)
VALUES (?, ?, ?, ?, ?)
`

type CreateLeaveParams struct {
	EmpID     int64         `json:"emp_id"`
	LeaveType string        `json:"leave_type"`
	LeaveDate time.Time     `json:"leave_date"`
	Reason    string        `json:"reason"`
	AddedBy   sql.NullInt64 `json:"added_by"`
}

func (q *Queries) CreateLeave(ctx context.Context, arg CreateLeaveParams) error {
	_, err := q.db.ExecContext(ctx, createLeave,
		arg.EmpID,
		arg.LeaveType,
		arg.LeaveDate,
		arg.Reason,
		arg.AddedBy,
	)
	return err
}

const deleteLeave = `-- name: DeleteLeave :exec
DELETE FROM HR_EMP_LEAVES 
WHERE id = ? AND emp_id = ?
`

type DeleteLeaveParams struct {
	ID    int64 `json:"id"`
	EmpID int64 `json:"emp_id"`
}

func (q *Queries) DeleteLeave(ctx context.Context, arg DeleteLeaveParams) error {
	_, err := q.db.ExecContext(ctx, deleteLeave, arg.ID, arg.EmpID)
	return err
}

const getEmployeeLeaveBenefits = `-- name: GetEmployeeLeaveBenefits :many
SELECT 
    id,
    leave_status,
    leave_type,
    leave_count,
    employee_id
FROM HR_EMP_Benifits 
WHERE employee_id = ? AND leave_status = 1
`

type GetEmployeeLeaveBenefitsRow struct {
	ID          int64  `json:"id"`
	LeaveStatus bool   `json:"leave_status"`
	LeaveType   string `json:"leave_type"`
	LeaveCount  int32  `json:"leave_count"`
	EmployeeID  int64  `json:"employee_id"`
}

func (q *Queries) GetEmployeeLeaveBenefits(ctx context.Context, employeeID int64) ([]GetEmployeeLeaveBenefitsRow, error) {
	rows, err := q.db.QueryContext(ctx, getEmployeeLeaveBenefits, employeeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEmployeeLeaveBenefitsRow
	for rows.Next() {
		var i GetEmployeeLeaveBenefitsRow
		if err := rows.Scan(
			&i.ID,
			&i.LeaveStatus,
			&i.LeaveType,
			&i.LeaveCount,
			&i.EmployeeID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEmployeeLeaves = `-- name: GetEmployeeLeaves :many
SELECT 
    l.id,
    l.emp_id,
    l.leave_type,
    l.leave_date,
    l.reason,
    l.create_date,
    COUNT(*) OVER() as total_count
FROM HR_EMP_LEAVES l
WHERE l.emp_id = ?
ORDER BY l.leave_date DESC
LIMIT ? OFFSET ?
`

type GetEmployeeLeavesParams struct {
	EmpID  int64 `json:"emp_id"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetEmployeeLeavesRow struct {
	ID         int64        `json:"id"`
	EmpID      int64        `json:"emp_id"`
	LeaveType  string       `json:"leave_type"`
	LeaveDate  time.Time    `json:"leave_date"`
	Reason     string       `json:"reason"`
	CreateDate sql.NullTime `json:"create_date"`
	TotalCount interface{}  `json:"total_count"`
}

func (q *Queries) GetEmployeeLeaves(ctx context.Context, arg GetEmployeeLeavesParams) ([]GetEmployeeLeavesRow, error) {
	rows, err := q.db.QueryContext(ctx, getEmployeeLeaves, arg.EmpID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEmployeeLeavesRow
	for rows.Next() {
		var i GetEmployeeLeavesRow
		if err := rows.Scan(
			&i.ID,
			&i.EmpID,
			&i.LeaveType,
			&i.LeaveDate,
			&i.Reason,
			&i.CreateDate,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLeaveSummaryByEmployee = `-- name: GetLeaveSummaryByEmployee :many
SELECT 
    l.emp_id,
    l.leave_type,
    COUNT(*) as used_count,
    b.leave_count as allowed_count,
    (b.leave_count - COUNT(*)) as remaining_count,
    e.first_name,
    e.last_name
FROM HR_EMP_LEAVES l
JOIN HR_Employee e ON l.emp_id = e.id
JOIN HR_EMP_Benifits b ON l.emp_id = b.employee_id AND l.leave_type = b.leave_type
WHERE 
    YEAR(l.leave_date) = YEAR(CURDATE()) AND
    b.leave_status = 1 AND
    (? = 0 OR l.emp_id = ?)
GROUP BY l.emp_id, l.leave_type, b.leave_count, e.first_name, e.last_name
ORDER BY e.first_name, e.last_name, l.leave_type
`

type GetLeaveSummaryByEmployeeParams struct {
	Column1 interface{} `json:"column_1"`
	EmpID   int64       `json:"emp_id"`
}

type GetLeaveSummaryByEmployeeRow struct {
	EmpID          int64  `json:"emp_id"`
	LeaveType      string `json:"leave_type"`
	UsedCount      int64  `json:"used_count"`
	AllowedCount   int32  `json:"allowed_count"`
	RemainingCount int32  `json:"remaining_count"`
	FirstName      string `json:"first_name"`
	LastName       string `json:"last_name"`
}

func (q *Queries) GetLeaveSummaryByEmployee(ctx context.Context, arg GetLeaveSummaryByEmployeeParams) ([]GetLeaveSummaryByEmployeeRow, error) {
	rows, err := q.db.QueryContext(ctx, getLeaveSummaryByEmployee, arg.Column1, arg.EmpID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLeaveSummaryByEmployeeRow
	for rows.Next() {
		var i GetLeaveSummaryByEmployeeRow
		if err := rows.Scan(
			&i.EmpID,
			&i.LeaveType,
			&i.UsedCount,
			&i.AllowedCount,
			&i.RemainingCount,
			&i.FirstName,
			&i.LastName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLeaveTypesForEmployee = `-- name: GetLeaveTypesForEmployee :many
SELECT 
    leave_type,
    leave_count,
    leave_status
FROM HR_EMP_Benifits 
WHERE employee_id = ? AND leave_status = 1
`

type GetLeaveTypesForEmployeeRow struct {
	LeaveType   string `json:"leave_type"`
	LeaveCount  int32  `json:"leave_count"`
	LeaveStatus bool   `json:"leave_status"`
}

func (q *Queries) GetLeaveTypesForEmployee(ctx context.Context, employeeID int64) ([]GetLeaveTypesForEmployeeRow, error) {
	rows, err := q.db.QueryContext(ctx, getLeaveTypesForEmployee, employeeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLeaveTypesForEmployeeRow
	for rows.Next() {
		var i GetLeaveTypesForEmployeeRow
		if err := rows.Scan(&i.LeaveType, &i.LeaveCount, &i.LeaveStatus); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateLeave = `-- name: UpdateLeave :exec
UPDATE HR_EMP_LEAVES 
SET 
    leave_type = ?,
    leave_date = ?,
    reason = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ? AND emp_id = ?
`

type UpdateLeaveParams struct {
	LeaveType string    `json:"leave_type"`
	LeaveDate time.Time `json:"leave_date"`
	Reason    string    `json:"reason"`
	ID        int64     `json:"id"`
	EmpID     int64     `json:"emp_id"`
}

func (q *Queries) UpdateLeave(ctx context.Context, arg UpdateLeaveParams) error {
	_, err := q.db.ExecContext(ctx, updateLeave,
		arg.LeaveType,
		arg.LeaveDate,
		arg.Reason,
		arg.ID,
		arg.EmpID,
	)
	return err
}
