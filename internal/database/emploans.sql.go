// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: emploans.sql

package database

import (
	"context"
	"database/sql"
)

const createRequest = `-- name: CreateRequest :exec
INSERT INTO emp_loan_req (emp_id, reason, amount, status, declined_by, decline_reason) VALUES (
    ?, ?, ?, ?, ?, ?
)
`

type CreateRequestParams struct {
	EmpID         int64          `json:"emp_id"`
	Reason        sql.NullString `json:"reason"`
	Amount        sql.NullString `json:"amount"`
	Status        sql.NullString `json:"status"`
	DeclinedBy    sql.NullInt64  `json:"declined_by"`
	DeclineReason sql.NullString `json:"decline_reason"`
}

func (q *Queries) CreateRequest(ctx context.Context, arg CreateRequestParams) error {
	_, err := q.db.ExecContext(ctx, createRequest,
		arg.EmpID,
		arg.Reason,
		arg.Amount,
		arg.Status,
		arg.DeclinedBy,
		arg.DeclineReason,
	)
	return err
}

const deleteRequest = `-- name: DeleteRequest :exec
DELETE FROM emp_loan_req WHERE id = ?
`

func (q *Queries) DeleteRequest(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteRequest, id)
	return err
}

const getRequests = `-- name: GetRequests :many
SELECT 
    id,
    emp_id,
    reason,
    amount,
    status,
    declined_by,
    decline_reason,
    requested_date,
    status_changed_date
FROM emp_loan_req 
ORDER BY requested_date ASC
LIMIT ? OFFSET ?
`

type GetRequestsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) GetRequests(ctx context.Context, arg GetRequestsParams) ([]EmpLoanReq, error) {
	rows, err := q.db.QueryContext(ctx, getRequests, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EmpLoanReq
	for rows.Next() {
		var i EmpLoanReq
		if err := rows.Scan(
			&i.ID,
			&i.EmpID,
			&i.Reason,
			&i.Amount,
			&i.Status,
			&i.DeclinedBy,
			&i.DeclineReason,
			&i.RequestedDate,
			&i.StatusChangedDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRequestsAdmin = `-- name: GetRequestsAdmin :many
SELECT 
    e.id,
    e.emp_id,
    usr.branch_id,
    br.name,
    e.reason,
    e.amount,
    e.status,
    e.declined_by,
    e.decline_reason,
    e.requested_date,
    e.status_changed_date
FROM emp_loan_req e
JOIN HR_EMP_User usr ON e.emp_id = usr.employee_id
JOIN HR_Branch br ON usr.branch_id = br.id
WHERE (1=br.id OR br.id = ?)
ORDER BY requested_date ASC
LIMIT ? OFFSET ?
`

type GetRequestsAdminParams struct {
	ID     int64 `json:"id"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetRequestsAdminRow struct {
	ID                int64          `json:"id"`
	EmpID             int64          `json:"emp_id"`
	BranchID          int64          `json:"branch_id"`
	Name              string         `json:"name"`
	Reason            sql.NullString `json:"reason"`
	Amount            sql.NullString `json:"amount"`
	Status            sql.NullString `json:"status"`
	DeclinedBy        sql.NullInt64  `json:"declined_by"`
	DeclineReason     sql.NullString `json:"decline_reason"`
	RequestedDate     sql.NullTime   `json:"requested_date"`
	StatusChangedDate sql.NullTime   `json:"status_changed_date"`
}

func (q *Queries) GetRequestsAdmin(ctx context.Context, arg GetRequestsAdminParams) ([]GetRequestsAdminRow, error) {
	rows, err := q.db.QueryContext(ctx, getRequestsAdmin, arg.ID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRequestsAdminRow
	for rows.Next() {
		var i GetRequestsAdminRow
		if err := rows.Scan(
			&i.ID,
			&i.EmpID,
			&i.BranchID,
			&i.Name,
			&i.Reason,
			&i.Amount,
			&i.Status,
			&i.DeclinedBy,
			&i.DeclineReason,
			&i.RequestedDate,
			&i.StatusChangedDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRequest = `-- name: UpdateRequest :exec
UPDATE emp_loan_req
SET reason = ?, amount = ?
WHERE id = ?
`

type UpdateRequestParams struct {
	Reason sql.NullString `json:"reason"`
	Amount sql.NullString `json:"amount"`
	ID     int64          `json:"id"`
}

func (q *Queries) UpdateRequest(ctx context.Context, arg UpdateRequestParams) error {
	_, err := q.db.ExecContext(ctx, updateRequest, arg.Reason, arg.Amount, arg.ID)
	return err
}

const updateRequestStatus = `-- name: UpdateRequestStatus :exec
UPDATE emp_loan_req 
SET status = ?, declined_by = ?, decline_reason = ? 
WHERE id = ?
`

type UpdateRequestStatusParams struct {
	Status        sql.NullString `json:"status"`
	DeclinedBy    sql.NullInt64  `json:"declined_by"`
	DeclineReason sql.NullString `json:"decline_reason"`
	ID            int64          `json:"id"`
}

func (q *Queries) UpdateRequestStatus(ctx context.Context, arg UpdateRequestStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateRequestStatus,
		arg.Status,
		arg.DeclinedBy,
		arg.DeclineReason,
		arg.ID,
	)
	return err
}
