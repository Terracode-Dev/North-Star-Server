// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: emploans.sql

package database

import (
	"context"
	"database/sql"
)

const createRequest = `-- name: CreateRequest :exec
INSERT INTO emp_loan_req (emp_id, reason, amount, status, declined_by, decline_reason) VALUES (
    ?, ?, ?, ?, ?, ?
)
`

type CreateRequestParams struct {
	EmpID         int64          `json:"emp_id"`
	Reason        sql.NullString `json:"reason"`
	Amount        sql.NullString `json:"amount"`
	Status        sql.NullString `json:"status"`
	DeclinedBy    sql.NullInt64  `json:"declined_by"`
	DeclineReason sql.NullString `json:"decline_reason"`
}

func (q *Queries) CreateRequest(ctx context.Context, arg CreateRequestParams) error {
	_, err := q.db.ExecContext(ctx, createRequest,
		arg.EmpID,
		arg.Reason,
		arg.Amount,
		arg.Status,
		arg.DeclinedBy,
		arg.DeclineReason,
	)
	return err
}

const deleteRequest = `-- name: DeleteRequest :exec
DELETE FROM emp_loan_req WHERE id = ?
`

func (q *Queries) DeleteRequest(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteRequest, id)
	return err
}

const getRequests = `-- name: GetRequests :many
SELECT 
    e.id,
    e.emp_id,
    CONCAT(em.first_name, '' , em.last_name) AS name,
    e.reason,
    e.amount,
    e.status,
    e.declined_by,
    e.decline_reason,
    e.requested_date,
    e.status_changed_date
FROM emp_loan_req e
JOIN HR_Employee em ON e.emp_id = em.id
WHERE 
    (? = '' OR em.first_name LIKE CONCAT('%',?,'%'))
    AND(? = '' OR em.last_name LIKE CONCAT('%', ? ,'%'))    
ORDER BY requested_date ASC
LIMIT ? OFFSET ?
`

type GetRequestsParams struct {
	Column1  interface{} `json:"column_1"`
	CONCAT   interface{} `json:"CONCAT"`
	Column3  interface{} `json:"column_3"`
	CONCAT_2 interface{} `json:"CONCAT_2"`
	Limit    int32       `json:"limit"`
	Offset   int32       `json:"offset"`
}

type GetRequestsRow struct {
	ID                int64          `json:"id"`
	EmpID             int64          `json:"emp_id"`
	Name              string         `json:"name"`
	Reason            sql.NullString `json:"reason"`
	Amount            sql.NullString `json:"amount"`
	Status            sql.NullString `json:"status"`
	DeclinedBy        sql.NullInt64  `json:"declined_by"`
	DeclineReason     sql.NullString `json:"decline_reason"`
	RequestedDate     sql.NullTime   `json:"requested_date"`
	StatusChangedDate sql.NullTime   `json:"status_changed_date"`
}

func (q *Queries) GetRequests(ctx context.Context, arg GetRequestsParams) ([]GetRequestsRow, error) {
	rows, err := q.db.QueryContext(ctx, getRequests,
		arg.Column1,
		arg.CONCAT,
		arg.Column3,
		arg.CONCAT_2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRequestsRow
	for rows.Next() {
		var i GetRequestsRow
		if err := rows.Scan(
			&i.ID,
			&i.EmpID,
			&i.Name,
			&i.Reason,
			&i.Amount,
			&i.Status,
			&i.DeclinedBy,
			&i.DeclineReason,
			&i.RequestedDate,
			&i.StatusChangedDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRequestsAdmin = `-- name: GetRequestsAdmin :many
SELECT 
    e.id,
    e.emp_id,
    CONCAT(em.first_name, " " , em.last_name) AS name,
    usr.branch_id,
    br.name,
    e.reason,
    e.amount,
    e.status,
    e.declined_by,
    e.decline_reason,
    e.requested_date,
    e.status_changed_date
FROM emp_loan_req e
JOIN HR_EMP_User usr ON e.emp_id = usr.employee_id
JOIN HR_Branch br ON usr.branch_id = br.id
JOIN HR_Employee em ON e.emp_id = em.id
WHERE 
    (1=br.id OR br.id = ?)
    AND(? = '' OR em.first_name LIKE CONCAT('%',?,'%'))
    AND(? = '' OR em.last_name LIKE CONCAT('%', ? ,'%'))
ORDER BY requested_date ASC
LIMIT ? OFFSET ?
`

type GetRequestsAdminParams struct {
	ID       int64       `json:"id"`
	Column2  interface{} `json:"column_2"`
	CONCAT   interface{} `json:"CONCAT"`
	Column4  interface{} `json:"column_4"`
	CONCAT_2 interface{} `json:"CONCAT_2"`
	Limit    int32       `json:"limit"`
	Offset   int32       `json:"offset"`
}

type GetRequestsAdminRow struct {
	ID                int64          `json:"id"`
	EmpID             int64          `json:"emp_id"`
	Name              string         `json:"name"`
	BranchID          int64          `json:"branch_id"`
	Name_2            string         `json:"name_2"`
	Reason            sql.NullString `json:"reason"`
	Amount            sql.NullString `json:"amount"`
	Status            sql.NullString `json:"status"`
	DeclinedBy        sql.NullInt64  `json:"declined_by"`
	DeclineReason     sql.NullString `json:"decline_reason"`
	RequestedDate     sql.NullTime   `json:"requested_date"`
	StatusChangedDate sql.NullTime   `json:"status_changed_date"`
}

func (q *Queries) GetRequestsAdmin(ctx context.Context, arg GetRequestsAdminParams) ([]GetRequestsAdminRow, error) {
	rows, err := q.db.QueryContext(ctx, getRequestsAdmin,
		arg.ID,
		arg.Column2,
		arg.CONCAT,
		arg.Column4,
		arg.CONCAT_2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRequestsAdminRow
	for rows.Next() {
		var i GetRequestsAdminRow
		if err := rows.Scan(
			&i.ID,
			&i.EmpID,
			&i.Name,
			&i.BranchID,
			&i.Name_2,
			&i.Reason,
			&i.Amount,
			&i.Status,
			&i.DeclinedBy,
			&i.DeclineReason,
			&i.RequestedDate,
			&i.StatusChangedDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTotalLoanRows = `-- name: GetTotalLoanRows :one
SELECT COUNT(*) AS Total_Rows FROM emp_loan_req
`

func (q *Queries) GetTotalLoanRows(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, getTotalLoanRows)
	var total_rows int64
	err := row.Scan(&total_rows)
	return total_rows, err
}

const updateRequest = `-- name: UpdateRequest :exec
UPDATE emp_loan_req
SET reason = ?, amount = ?
WHERE id = ?
`

type UpdateRequestParams struct {
	Reason sql.NullString `json:"reason"`
	Amount sql.NullString `json:"amount"`
	ID     int64          `json:"id"`
}

func (q *Queries) UpdateRequest(ctx context.Context, arg UpdateRequestParams) error {
	_, err := q.db.ExecContext(ctx, updateRequest, arg.Reason, arg.Amount, arg.ID)
	return err
}

const updateRequestStatus = `-- name: UpdateRequestStatus :exec
UPDATE emp_loan_req 
SET status = ?, declined_by = ?, decline_reason = ? 
WHERE id = ?
`

type UpdateRequestStatusParams struct {
	Status        sql.NullString `json:"status"`
	DeclinedBy    sql.NullInt64  `json:"declined_by"`
	DeclineReason sql.NullString `json:"decline_reason"`
	ID            int64          `json:"id"`
}

func (q *Queries) UpdateRequestStatus(ctx context.Context, arg UpdateRequestStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateRequestStatus,
		arg.Status,
		arg.DeclinedBy,
		arg.DeclineReason,
		arg.ID,
	)
	return err
}
